---
title: "SCT Task 2"
author: "Michael Bohl"
date: "2024-04-24"
output: html_document
---

## IMPORTS, install libraries if needed
```{r}
required_libraries = c("BiocManager", "R.utils", "Seurat", "Matrix", "dplyr", "patchwork", "devtools", "simspec", "ggplot2", "ggrepel", "DESeq2", "scran", "pbapply", "presto")

# load libraries and install from CRAN if necessary
for (library_name in required_libraries) {
  if (!requireNamespace(library_name, quietly = TRUE)) {
    message(paste("Installing and loading library", library_name))
    install.packages(library_name)
  }
  library(library_name, character.only = TRUE)
}

# libraries that are not available from CRAN
# BiocManager::install("Seurat")
# BiocManager::install("DESeq2")
# BiocManager::install("scran")
# devtools::install_github("immunogenomics/presto")
# devtools::install_github('quadbio/simspec')

```

### Part 1. Descriptive analysis of the data set


## read in the data (rename the counts file to matrix.mtx.gtz)
```{r}
counts <- Read10X("./data", gene.column=1)
meta <- read.table("./data/meta.tsv.gz")
seurat <- CreateSeuratObject(counts, meta.data = meta)
```


## routine processing
```{r}
# Normalize, find variable features, remove cell cycle genes, and scale data
seurat <- NormalizeData(seurat) %>%
  FindVariableFeatures(nfeatures = 2000) %>%
  CellCycleScoring(s.features = cc.genes.updated.2019$s.genes, g2m.features = cc.genes.updated.2019$g2m.genes)
VariableFeatures(seurat) <- setdiff(VariableFeatures(seurat), c(unlist(cc.genes.updated.2019), grep("^MT-", rownames(seurat), value=T))) # remove cell cycle genes and mitochondrial genes

seurat <- ScaleData(seurat, vars.to.regress = c("G2M.Score","S.Score")) %>% # regress out cell cycle scores
  RunPCA(npcs = 20) %>% #10 PCAs as in the paper
  RunUMAP(dims = 1:10, min.dist = 0.5, spread = 0.5)

plot1 <- UMAPPlot(seurat, group.by="organoid") & NoAxes()
plot2 <- FeaturePlot(seurat, c("FOXG1","EMX1","DLX2","MKI67"), order=T) & NoAxes() & NoLegend()
plot1 | plot2
```  


## CSS integration
```{r}
seurat <- cluster_sim_spectrum(seurat, label_tag = "organoid", cluster_resolution = 1)
seurat <- RunUMAP(seurat, reduction = "css", dims = 1:ncol(Embeddings(seurat,"css")), reduction.name = "umap_css", reduction.key = "UMAPCSS_")
plot1 <- DimPlot(seurat, reduction = "umap_css", group.by="GLI3_status") & NoAxes()
plot1 <- DimPlot(seurat, reduction = "umap_css", group.by="organoid") & NoAxes()
plot2 <- FeaturePlot(seurat, c("FOXG1","EMX1","DLX2","MKI67"), reduction = "umap_css", order=T) & NoAxes() & NoLegend()
plot1 | plot2
```

  

## Cluster and annotate data
```{r}
seurat <- FindNeighbors(seurat, reduction = "css", dims = 1:ncol(Embeddings(seurat,"css"))) %>%
  FindClusters(resolution = 0.9)

plot1 <- DimPlot(seurat, reduction = "umap_css", label = T) & NoAxes()
plot2 <- FeaturePlot(seurat, c("SOX2","DCX","FOXG1","EMX1","DLX2","MKI67","OTX2","HOXB2","TTR"),
                     reduction = "umap_css", order=T) & NoAxes() & NoLegend()
plot1 | plot2

# TODO: annotate clusters, this is too inaccurate
seurat@meta.data$region <- factor(setNames(c("non-telen.",
                                   "non-telen.",
                                   "mixed",
                                   "non-telen.",
                                   "non-telen.",
                                   "ventral telen.",
                                   "non-telen.",
                                   "dorsal telen.",
                                   "mixed",
                                   "non-telen.",
                                   "non-telen.",
                                   "non-telen.",
                                   "mixed",
                                   "non-telen.",
                                   "dorsal telen.",
                                   "dorsal telen.",
                                   "ventral telen.",
                                   "non-telen.",
                                   "mixed",
                                   "non-telen.",
                                   "non-telen.", 
                                  "dorsal telen."),
                                 levels(seurat))[seurat@active.ident],
                        levels=c("dorsal telen.","ventral telen.","non-telen.","mixed"))
plot1 <- DimPlot(seurat, reduction = "umap_css", group.by = "region") & NoAxes()
plot2 <- FeaturePlot(seurat, c("SOX2","DCX","FOXG1","EMX1","DLX2","MKI67","OTX2","HOXB2","TTR"), reduction = "umap_css", order=T) & NoAxes() & NoLegend()
plot1 | plot2
```

### Part 2. Comparison of cell type compositions between conditions

## visually check cell type compositions
```{r}
freq <- table(seurat@meta.data$region, seurat$organoid) # create a frequency table of annotated cell types
prop <- apply(freq,2,function(x) x/sum(x)) # calculate the proportion of each cell type

layout(matrix(1:3,nrow=1)); par(mar=c(8,5,1,1)) # set the layout for the plots
barplot(freq, col=c("#E74C3C","#A569BD","#76D7C4","#CCD1D1"),
        border=NA, las=2, ylab="Frequency", cex.names = 0.8)
barplot(prop, col=c("#E74C3C","#A569BD","#76D7C4","#CCD1D1"),
        border=NA, las=2, ylab="Proportion", cex.names = 0.8)
plot.new()
legend("left", fill=c("#E74C3C","#A569BD","#76D7C4","#CCD1D1"), legend=rownames(freq), bty="n")

```
# visible difference between WT and KO: ... (fix once clusters are annotated)


## compare cells using Fisher's exact test
```{r}
freq_fisher <- function(conditions, have_identity){
  freq <- table(factor(have_identity, levels=c(TRUE,FALSE)),
                conditions)
  test <- fisher.test(freq)
  res <- setNames(c(test$estimate, test$p.value), c("oddsratio","pval_fisher"))
  return(res)
}

region_enrichment <- data.frame(region = levels(seurat@meta.data$region),
                                # loop and test every region
                                t(sapply(levels(seurat@meta.data$region), function(region)
                                  freq_fisher(conditions = factor(seurat$GLI3_status, levels=c("KO","WT")),
                                              have_identity = seurat@meta.data$region == region)
                                )),
                                row.names=NULL)
region_enrichment$padj_fisher <- p.adjust(region_enrichment$pval_fisher)

region_enrichment
```

## GLM with binomial distribution, followed by ANOVA

```{r}
freq_glm_aov <- function(samples, conditions, have_identity){
  sample_conditions <- unique(data.frame(sample = samples, condition = conditions))
  sample_conditions <- setNames(sample_conditions$condition, sample_conditions$sample)

  freq <- table(samples, factor(have_identity, levels=c(TRUE,FALSE)))
  m <- glm(freq ~ sample_conditions[rownames(freq)], family = "binomial")
  aov <- anova(m, test = "Chisq")
  res <- setNames(c(coef(m)[2], aov$Pr[2]), c("coef_glm","pval_aov"))
  return(res)
}

region_enrichment <- data.frame(region_enrichment,
  # loop and test every region
  t(sapply(levels(seurat$region), function(region){
    freq_glm_aov(samples = seurat$organoid,
                 conditions = factor(seurat$GLI3_status, levels=c("WT","KO")),
                 seurat$region == region)
  })),
  row.names=NULL)
region_enrichment$padj_aov <- p.adjust(region_enrichment$pval_aov)
region_enrichment
```

## differential gene expression analysis: first, measure similarity between the clusters, then do a Wilcoxon test for DE
```{r}
seurat_ventral <- subset(seurat, subset = seurat_clusters == 0) %>%
  FindVariableFeatures()

DE_wilcoxauc_ventral <- wilcoxauc(seurat_ventral, group_by = "GLI3_status") %>%
  filter(group == "KO") %>%
  mutate(DE = abs(logFC)>log(1.1) & padj < 0.01) %>%
  mutate(DEG = ifelse(abs(logFC)>log(1.1) & padj < 0.01, feature, NA))

# volcano plot
library(EnhancedVolcano)
library(ggrepel)

# make enhanced volcanoplot
EnhancedVolcano(DE_wilcoxauc_ventral, x = "logFC", y = "padj", lab = DE_wilcoxauc_ventral$DEG, title = "Ventral telen.", pCutoff = 0.01, FCcutoff = log(1.1), xlim = c(-1.5,1.5))



ggplot(DE_wilcoxauc_ventral, aes(x = logFC, y = -log10(padj), col=DE, label=DEG)) +
  geom_point() +
  geom_text_repel() +
  geom_vline(xintercept=c(-log(1.1), log(1.1), 0), col="#303030", linetype="dotted") +
  geom_hline(yintercept=-log10(0.01), col="#303030", linetype="dotted") +
  scale_color_manual(values=c("#909090", "red")) +
  theme_minimal()

```

## Do the same wit DESeq2
```{r}
# Get the counts matrix
counts <- GetAssayData(seurat_ventral, assay = "RNA", slot = "counts")

# Filter genes based on detection rate
det_rate <- rowMeans(counts > 0)
filtered_counts <- counts[det_rate > 0.05, ]

# Add metadata (assuming 'GLI3_status' is in your metadata)
meta <- seurat_ventral@meta.data %>% mutate(GLI3_status = factor(GLI3_status, levels=c("WT","KO")))

# Create DESeqDataSet
dds <- DESeqDataSetFromMatrix(countData = filtered_counts,
                              colData = meta,
                              design = ~ GLI3_status)

# Use the original counts for size factor calculation (not filtered)
all_counts <- GetAssayData(seurat_ventral, assay = "RNA", slot = "counts")
sizeFactors(dds) <- calculateSumFactors(all_counts)  

# DESeq analysis
dds <- DESeq(dds, test="LRT", reduced=~1, useT=TRUE, minmu=1e-6, minReplicatesForReplace=Inf)

# visualize that shiat
EnhancedVolcano(dds, x = "log2FoldChange", y = "pvalue", lab = rownames(dds), title = "Ventral telen.", pCutoff = 0.01, FCcutoff = log(1.1), xlim = c(-1.5,1.5))
  
```
## self(=Zhisong)-implemented model
```{r}
# to do DE test for one gene
aov_DE <- function(expr, cond, covar = NULL, family = "gaussian", test = NULL){
  if (is.null(covar)) covar <- data.frame(X_const = 1)
  dat <- data.frame(y = expr,
                    cond = cond,
		    covar)
  m <- glm(y ~ ., family = family, data = dat)
  m0 <- glm(y ~ . - cond, family = family, data = dat)

  if (is.null(test)){
    test <- "F"
    if (ifelse(is(family, "family"), family$family, family) %in% c("binomial","poisson"))
      test <- "Chisq"
  }
  aov <- anova(m, m0, test = test)

  res <- c(coef(m)[grep("^cond",names(coef(m)))], aov$Pr[2])
  names(res)[length(res)] <- "pval"
  return(res)
}

## test if it works

library(pbapply)

DE_aov <- data.frame(t(pbsapply(which(det_rate > 0.05), function(i)
  aov_DE(expr = seurat_ventral@assays$RNA$data[i,],
         cond = factor(seurat_ventral$GLI3_status, levels=c("WT","KO")),
         covar = data.frame(cov = log10(seurat_ventral$nCount_RNA))))), row.names=NULL)
DE_aov$padj <- p.adjust(DE_aov$pval, method="BH")
DE_aov <- data.frame(gene = names(which(det_rate > 0.05)), DE_aov) %>%
  mutate(DE = abs(condKO)>log(1.1) & padj < 0.01) %>%
  mutate(DEG = ifelse(abs(condKO)>log(1.1) & padj < 0.01, gene, NA))

DE_aov_bin <- data.frame(t(pbsapply(which(det_rate > 0.05), function(i)
  aov_DE(expr = seurat_ventral@assays$RNA$data[i,] > 0,
         cond = factor(seurat_ventral$GLI3_status, levels=c("WT","KO")),
         covar = data.frame(cov = seurat_ventral$nCount_RNA),
         family = "binomial"))), row.names=NULL)
DE_aov_bin$padj <- p.adjust(DE_aov_bin$pval, method="BH")
DE_aov_bin <- data.frame(gene = names(which(det_rate > 0.05)), DE_aov_bin) %>%
  mutate(DE = padj < 0.01) %>%
  mutate(DEG = ifelse(padj < 0.01, gene, NA))
```
## visualize the results
```{r}

plot1 <- EnhancedVolcano(DE_aov, lab = DE_aov$DEG, x = 'condKO', y = 'pval', xlim = c(-1.5, 1.5), title = 'aov', pCutoff = 0.01, FCcutoff = 1.1)
plot2 <- EnhancedVolcano(DE_aov_bin, lab = DE_aov_bin$DEG, x = 'condKO', y = 'pval', xlim = c(-20, 20), title = 'aov_bin', pCutoff = 0.01, FCcutoff = 1.1)

```



## clustering

```{r}
seurat_ventral <- subset(seurat, subset = seurat_clusters == 0) %>%
  FindVariableFeatures()

# Use DefaultAssay to specify the assay
DefaultAssay(seurat) <- "RNA" 

# Calculate average expression for each organoid
avg_expr_org <- AverageExpression(seurat, assays = "RNA", slot = "data", group.by = "organoid")

# Convert to a matrix for further analysis
avg_expr_org_matrix <- as.matrix(avg_expr_org[["RNA"]])

# Filter to variable features
avg_expr_org_filtered <- avg_expr_org_matrix[VariableFeatures(seurat),]

# Remaining code (correlation and plotting) should work as before
corr_org <- cor(avg_expr_org_filtered, method = "spearman")
plot(hclust(as.dist(1-corr_org)))
``` 

## enrichment analysis
```{r}
library(enrichR))
databases <- c("GO_Biological_Process_2018", "GO_Molecular_Function_2018", "GO_Cellular_Component_2018", "KEGG_2019_Human", "Reactome_2016", "WikiPathways_2019_Human")
enrichment_results <- enrichR(DE_deseq2_ventral$DEG, databases = databases)

```

##GSEA

```{r}
# define a function to perform GSEA
GSEA <- function(gene_list) {
  gene_list <- gene_list %>% arrange(desc(log2FoldChange))
  
  
  
  # Convert gene symbols to Entrez IDs
  genes_entrez <- bitr(gene_list$gene_name, 
                       fromType = "SYMBOL", 
                       toType = "ENTREZID", 
                       OrgDb = org.Hs.eg.db)
  
  # Handle duplicates by keeping only the first mapping or summarizing appropriately
  genes_entrez <- genes_entrez %>%
    group_by(SYMBOL) %>%
    slice_head(n = 1) %>%
    ungroup()
  
  # Merge gene_list with genes_entrez to preserve ranking order
  gene_list <- gene_list %>%
    inner_join(genes_entrez, by = c("gene_name" = "SYMBOL"))
  
  # Check if the merging step resulted in any duplicates and ensure unique Entrez IDs
  gene_list <- gene_list %>%
    distinct(ENTREZID, .keep_all = TRUE)

  # Create a named vector of log2FoldChange with Entrez IDs as names
  ranked_genes <- gene_list$log2FoldChange
  names(ranked_genes) <- gene_list$ENTREZID
  
  
  # Ensure the gene list is sorted in decreasing order
  ranked_genes <- sort(ranked_genes, decreasing = TRUE)
  
  # Perform GSEA with Reactome pathways
  reactome_gsea_result <- gsePathway(
    geneList = ranked_genes,
    organism = "human",
    pvalueCutoff = 0.05,
    pAdjustMethod = "BH", # Benjamini-Hochberg adjustment
    verbose = TRUE,
    BPPARAM = BiocParallel::SerialParam()
  )
  

  return(reactome_gsea_result[order(abs(reactome_gsea_result$NES), decreasing = TRUE),])
  


}

```

## visualize the results
```{r}
results %>% head(10) %>%
        ggplot(aes(x = reorder(Description, NES), y = NES, size = setSize, color = p.adjust)) +
    geom_point(alpha = 0.7) +
    coord_flip() +
    scale_color_gradient(low = "blue", high = "red") +
    labs(title = "Reactome Pathway GSEA", x = "Pathway", y = "Normalized Enrichment Score (NES)") +
    theme_minimal()
```

